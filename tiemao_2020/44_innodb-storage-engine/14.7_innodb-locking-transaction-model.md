# 14.7 InnoDB Locking and Transaction Model

# 14.7 锁和InnoDB事务模型

[TOC]

To implement a large-scale, busy, or highly reliable database application, to port substantial code from a different database system, or to tune MySQL performance, it is important to understand InnoDB locking and the InnoDB transaction model.

This section discusses several topics related to InnoDB locking and the InnoDB transaction model with which you should be familiar.

Section 14.7.1, “InnoDB Locking” describes lock types used by InnoDB.

Section 14.7.2, “InnoDB Transaction Model” describes transaction isolation levels and the locking strategies used by each. It also discusses the use of autocommit, consistent non-locking reads, and locking reads.

Section 14.7.3, “Locks Set by Different SQL Statements in InnoDB” discusses specific types of locks set in InnoDB for various statements.

Section 14.7.4, “Phantom Rows” describes how InnoDB uses next-key locking to avoid phantom rows.

Section 14.7.5, “Deadlocks in InnoDB” provides a deadlock example, discusses deadlock detection, and provides tips for minimizing and handling deadlocks in InnoDB.


想要实现高吞吐、高可靠的大型数据库应用系统;
想要从其他数据库管理系统迁移到MySQL;
想进行MySQL性能调优;
那么学习和掌握InnoDB锁和InnoDB事务模型至关重要。

本节讲解InnoDB锁和InnoDB事务模型,对应的主题包括:

- 14.7.1, “InnoDB Locking”, 介绍InnoDB中使用的锁类型。
- 14.7.2, “InnoDB Transaction Model”, 描述事务隔离级别(transaction isolation level), 以及每种隔离级别使用的锁策略。 还会介绍如何使用 自动提交(autocommit), 一致性非锁定读(consistent non-locking read), 和锁定读(locking read)。
- 14.7.3, “Locks Set by Different SQL Statements in InnoDB”, 讨论InnoDB为各种语句设置的锁。
- 14.7.4, “Phantom Rows”, 幻影行, 描述了InnoDB怎么使用 next-key locking 来解决幻读。
- 14.7.5, “Deadlocks in InnoDB”, 通过一个死锁示例, 来讨论死锁问题, 并介绍一些在InnoDB中降低和减少死锁的技巧。


> https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-transaction-model.html



















-
