# Java多线程与并发面试题

[TOC]


## 1. 线程基础


### 1.1 什么是线程?

线程(Thread)就是程序代码执行的一条线, 在Java代码层面看来, 是一个方法调用另一个方法，依次排列的方法调用链。

当然，线程是操作系统中的概念，被称为轻量级的进程，是分配CPU资源和调度执行的基本单位。


### 1.2 什么是进程?

进程(Processe)是操作系统中的概念，是应用程序的一次动态执行过程，操作系统会给他分配各种资源，比如内存，文件，以及CPU资源。

每个进程都有自己的内存空间，相对于静态的应用程序二进制代码来说，这个虚拟内存地址空间就是一个副本。

比如，我们用命令行启动一次Java程序，就说启动了一个JVM进程。


### 1.3 线程与进程有什么区别?

一般来说，进程中可以包含多个线程，这些线程共享一块内存地址空间。
在Linux系统中，线程和进程概念并没有严格区分。

粗略来看，它们的区别有：

线程被称为轻量级的进程，线程之间的切换开销更小，线程占用的资源比进程少。
进程之间是独立的，不能共享内存地址空间；【Linux的轻量级进程我们当做线程来看即可】


### 1.4 Java中怎么创建线程?

Java语言中创建线程本质上只有一种方式: `new Thread()`。 启动线程则是调用 `start()` 方法。

Java中,继承 Thread 类,实现 Runnable 接口,实现 Callable 接口, 这些方式创建的都是可执行任务，并没有真正地创建线程。


### 1.5  `Thread#start()` 和 `Thread#run()` 方法有什么区别？

- `Thread#start()`: 启动一个新线程并异步执行其中的任务。
- `Thread#run()`: 在当前线程执行，和调用其他对象的普通方法没什么区别。


### 1.6 Thread类与Runnable接口有什么关系?

Thread类继承了Runnable接口，创建线程对象时，可以传入需要执行的 Runnable 任务。


### 1.7 Runnable 与 Callable 接口有什么区别？

- `Runnable#run()` 没有返回值
- `Callable#call()` 方法有返回值


### 1.8 线程有哪些状态?

Thread的状态包括:

- NEW：初始状态, 尚未启动
- RUNNABLE: 可运行状态
- RUNNING: 运行中
- READY: 就绪状态
- WAITING: 等待状态
- TIMED_WAITING: 限时等待被唤醒的状态
- BLOCKED: 阻塞状态,被对象锁或者IO阻塞
- TERMINATED: 终止状态


### 1.9 什么是守护线程？与前台线程的区别在哪里?


守护线程(Daemon Thread)也叫后台线程。

在JVM中，如果没有正在运行中的前台线程，则JVM就会自动结束运行，而不管守护线程。 所以守护线程一般用于执行某些可以被放弃的任务或事件。


### 1.10 `Thread.sleep(0)` 与 `TimeUnit.MILLISECONDS.sleep(0)` 有什么不同?

`TimeUnit.MILLISECONDS.sleep(0)` 没有效果，因为数值 `0` 会被过滤掉。

两种方法都可以实现线程休眠，让出CPU资源。

`Thread.sleep(0L)` 的用处是先让出CPU资源，然后再让操作系统进行调度，和 `Thread.yield()` 类似。

`TimeUnit.MILLISECONDS.sleep()` 方法是对 `Thread.sleep()` 的快捷封装。


## 2. 多线程与并发


### 2.1 并行和并发在你看来有什么区别？

- concurrent: 并发, 指多个线程在共同完成一件事情; 互相之间有依赖/有状态, 例如多个部门做同一个系统。
- parallel: 并行, 指多个线程各做各的事情; 互相之间无共享状态, 例如两个公司, 各做各的项目。

在GC算法中: concurrent指GC线程和业务线程一起执行的阶段； parallel则是指多个GC线程之间的并行执行。


### 2.2 为什么需要多线程?

多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务。

本质原因是摩尔定律失效，CPU进入多核时代。 加上互联网时代的来临，分布式系统开发大规模普及。


### 2.3 多线程有什么优势?

多线程编程方式，通过合理的分工，能充分利用多个CPU核心，提高程序的执行性能。

再比如一个餐馆，多个服务员之间可以看做是多个并行线程。 服务员和厨师之间则可以看多是多个并发线程。


### 2.4 多线程有什么不好的地方?

1. 多线程的程序更加复杂，开发成本更高；
2. 消耗更多的资源，比如内存，CPU等等；
3. 多线程需要协调和管理，会相互影响，有资源竞争问题。


### 2.5 如何让一个线程执行完再执行第二个？

使用 `Thread#join()` 方法，可以让当前线程阻塞, 等待指定的 thread 执行完成后，再执行当前线程。


### 2.6 怎样让两个线程以指定顺序交替执行?

可以使用细粒度的锁(fine-grained locks)来控制执行顺序。

- 比如使用Java内置的 `object.wait()` 和 `object.notify()` 方法，依次执行完并通知对方。
- 或者使用同一个锁的多个 Condition, 分别等待。
- 或者使用 CountDownLatch 和 CyclicBarrier 等工具进行辅助。

### 2.7 `Thread.sleep` 和 `Object#wait()` 的区别

- `Thread.sleep()`: 让出CPU
- `Object#wait()` : 释放锁


### 2.8 线程之间如何通信?


线程间通信(inter-thread communication)主要有两种方式:

1. 共享内存: 多个线程之间使用堆内存之中的对象/属性作为状态值,来进行隐式的通信。
2. 消息传递: 线程之间通过明确的发送消息来进行显式的通信。



## 3. 线程安全

### 3.1 什么是线程安全?

线程安全是多线程环境下的一个概念，保证多个线程并发执行同一段代码时, 不会出现不确定的结果, 也不会出现与单线程执行时不一致的结果。 也就是保证多个线程对共享状态操作的正确性。

在Java中, 完全由代码来控制线程安全, 共享状态一般是指堆内存中的数据（对象的属性）。


### 3.2 线程安全有哪些特征?

- 原子性: 临界区内的操作不会中途被其他线程干扰，一般通过同步机制来实现。
- 可见性: 一个线程执行的修改操作，对其他线程来说必须立即可见。 比如将修改的数据强制刷新到主内存、其他线程读取时也强制从主内存读取。
- 有序性: 保证线程内的串行语义，避免指令重排，例如增加内存屏障。


### 3.3 怎么保证线程安全？

- 使用原子类。
- 加锁: 例如 `synchronized`, `Lock`
- `object.wait()` 方法
- `object.notify()` 方法
- `thread.join()` 方法
- `CountdownLatch` 类
- `CyclicBarrier` 类
- `FutureTask` 类
- `Callable` 类


### 3.4 经常使用哪些线程安全的集合类?

- `ConcurrentHashMap`
- `CopyOnWriteArrayList`
- `ConcurrentLinkedQueue`
- `ConcurrentLinkedDeque`
- `Collections` 的 `synchronizedList` 等工具方法


### 3.5 类加载和初始化的过程是线程安全的吗? 哪些情况下是不安全的?

类加载的过程是同步阻塞方式的，所以是线程安全的。

类和对象初始化的过程也是同步阻塞的，但如果初始化代码中有引用泄漏，则可能造成其他问题。

### 3.6 ThreadLocal 是什么?

ThreadLocal, 线程本地变量。

### 3.7 ThreadLocal 的实现原理是什么?

每个 ThreadLocal 对象, 为每个线程提供独立的变量副本，所以每个线程都可以独立地改变自己的副本，而不会影响其它线程对应的副本。

### 3.8 ThreadLocal 有哪些使用场景？

- 维护遗留系统，避免增加方法调用参数，修改一连串方法签名
- Spring的JDBC连接以及事务管理
- 请求上下文: Tomcat基于线程的连接模型

### 3.9 使用 ThreadLocal 有哪些需要注意的地方?

- 注意防止污染: finally中及时进行清理, 避免污染下一次的请求。
- 防止内存泄漏: 避免将持有大量数据的对象放到ThreadLocal。
